自定义绘制知识的四个级别
    1.Canvas 的 drawXXX() 系列方法及 Paint 最常见的使用；
    2.Paint 的完全攻略 可以做的事，不只是设置颜色，也不只是我在视频里讲的实心空心、线条粗细、有没有阴影，它可以做的风格设置真的是非常多、非常细；
    3.Canvas 对绘制的辅助——范围裁切和几何变换；
    4.使用不同的绘制方法来控制绘制顺序。

onDraw()
    Canvas 类下的所有 draw- 打头的方法，例如 drawCircle() drawBitmap()。
    Paint 类的几个最常用的方法。具体是：
    Paint.setStyle(Style style) 设置绘制模式
    Paint.setColor(int color) 设置颜色
    Paint.setStrokeWidth(float width) 设置线条宽度
    Paint.setTextSize(float textSize) 设置文字大小
    Paint.setAntiAlias(boolean aa) 设置抗锯齿开关

Canvas方法:draw- 打头的方法，例如 drawCircle() drawBitmap()
    Canvas.drawColor(@ColorInt int color) 颜色填充
        drawRGB(int r, int g, int b) 和 drawARGB(int a, int r, int g, int b) ，它们和  drawColor(color) 只是使用方式不同，作用都是一样的。
    drawCircle(float centerX, float centerY, float radius, Paint paint) 画圆-->(前两个参数 centerX centerY 是圆心的坐标，第三个参数 radius 是圆的半径，单位都是像素，它们共同构成了这个圆的基本信息（即用这几个信息可以构建出一个确定的圆）；第四个参数 paint 我在视频里面已经说过了，它提供基本信息之外的所有风格信息，例如颜色、线条粗细、阴影等)
    drawRect(float left, float top, float right, float bottom, Paint paint) 画矩形-->left, top, right, bottom 是矩形四条边的坐标。
        drawRect(RectF rect, Paint paint) 和 drawRect(Rect rect, Paint paint) -->让你可以直接填写 RectF 或 Rect 对象来绘制矩形。
    drawPoint(float x, float y, Paint paint) 画点-->x 和 y 是点的坐标。点的大小可以通过 paint.setStrokeWidth(width) 来设置；点的形状可以通过  paint.setStrokeCap(cap) 来设置：ROUND 画出来是圆形的点，SQUARE 或 BUTT 画出来是方形的点。（点还有形状？是的，反正 Google 是这么说的，你要问问 Google 去，我也很懵逼。）
        drawPoints(float[] pts, int offset, int count, Paint paint) / drawPoints(float[] pts, Paint paint) 画点（批量）
    drawOval(float left, float top, float right, float bottom, Paint paint) 画椭圆
        drawOval(RectF rect, Paint paint)，让你可以直接填写 RectF 来绘制椭圆。
    drawLine(float startX, float startY, float stopX, float stopY, Paint paint) 画线-->startX, startY, stopX, stopY 分别是线的起点和终点坐标。由于直线不是封闭图形，所以 setStyle(style) 对直线没有影响。
        drawLines(float[] pts, int offset, int count, Paint paint) / drawLines(float[] pts, Paint paint) 画线（批量）
    drawRoundRect(float left, float top, float right, float bottom, float rx, float ry, Paint paint) 画圆角矩形-->left, top, right, bottom 是四条边的坐标，rx 和 ry 是圆角的横向半径和纵向半径。
        drawRoundRect(RectF rect, float rx, float ry, Paint paint)，让你可以直接填写 RectF 来绘制圆角矩形。
    drawArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean useCenter, Paint paint) 绘制弧形或扇形-->drawArc() 是使用一个椭圆来描述弧形的。left, top, right, bottom 描述的是这个弧形所在的椭圆；startAngle 是弧形的起始角度（x 轴的正向，即正右的方向，是 0 度的位置；顺时针为正角度，逆时针为负角度），sweepAngle 是弧形划过的角度；useCenter 表示是否连接到圆心，如果不连接到圆心，就是弧形，如果连接到圆心，就是扇形。
            paint.setStyle(Paint.Style.FILL); // 填充模式
            canvas.drawArc(200, 100, 800, 500, -110, 100, true, paint); // 绘制扇形
            canvas.drawArc(200, 100, 800, 500, 20, 140, false, paint); // 绘制弧形
            paint.setStyle(Paint.Style.STROKE); // 画线模式
            canvas.drawArc(200, 100, 800, 500, 180, 60, false, paint); // 绘制不封口的弧形
    drawPath(Path path, Paint paint) 画自定义图形
    drawBitmap(Bitmap bitmap, float left, float top, Paint paint) 画 Bitmap-->drawBitmap(Bitmap bitmap, float left, float top, Paint paint) 画 Bitmap
        drawBitmap(Bitmap bitmap, Rect src, RectF dst, Paint paint)
        drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint)
        drawBitmap(Bitmap bitmap, Matrix matrix, Paint paint)
        drawBitmap 还有一个兄弟方法 drawBitmapMesh()，可以绘制具有网格拉伸效果的 Bitmap。
    drawText(String text, float x, float y, Paint paint) 绘制文字-->界面里所有的显示内容，都是绘制出来的，包括文字。 drawText() 这个方法就是用来绘制文字的。参数  text 是用来绘制的字符串，x 和 y 是绘制的起点坐标。



Path方法:有两类方法，一类是直接描述路径的，另一类是辅助的设置或计算。
    Path 方法第一类：直接描述路径。
        第一组： addXxx() ——添加子图形
            addCircle(float x, float y, float radius, Direction dir) 添加圆-->x, y, radius 这三个参数是圆的基本信息，最后一个参数 dir 是画圆的路径的方向。路径方向有两种：顺时针 (CW clockwise) 和逆时针 (CCW counter-clockwise) 。对于普通情况，这个参数填 CW 还是填 CCW 没有影响。它只是在需要填充图形 (Paint.Style 为 FILL 或 FILL_AND_STROKE) ，并且图形出现自相交时，用于判断填充范围的
                Path.setFillType()
            addOval(float left, float top, float right, float bottom, Direction dir) / addOval(RectF oval, Direction dir) 添加椭圆
            addRect(float left, float top, float right, float bottom, Direction dir) / addRect(RectF rect, Direction dir) 添加矩形
            addRoundRect(RectF rect, float rx, float ry, Direction dir) / addRoundRect(float left, float top, float right, float bottom, float rx, float ry, Direction dir) / addRoundRect(RectF rect, float[] radii, Direction dir) / addRoundRect(float left, float top, float right, float bottom, float[] radii, Direction dir) 添加圆角矩形
            addPath(Path path) 添加另一个 Path

        第二组：xxxTo() ——画线（直线或曲线）-->这一组和第一组 addXxx() 方法的区别在于，第一组是添加的完整封闭图形（除了 addPath() ），而这一组添加的只是一条线。
            lineTo(float x, float y) / rLineTo(float x, float y) 画直线-->从当前位置向目标位置画一条直线， x 和 y 是目标位置的坐标。这两个方法的区别是，lineTo(x, y) 的参数是绝对坐标，而 rLineTo(x, y) 的参数是相对当前位置的相对坐标 （前缀 r 指的就是 relatively 「相对地」)。
                当前位置：所谓当前位置，即最后一次调用画 Path 的方法的终点位置。初始值为原点 (0, 0)。
                paint.setStyle(Style.STROKE);
                path.lineTo(100, 100); // 由当前位置 (0, 0) 向 (100, 100) 画一条直线
                path.rLineTo(100, 0); // 由当前位置 (100, 100) 向正右方 100 像素的位置画一条直线
            quadTo(float x1, float y1, float x2, float y2) / rQuadTo(float dx1, float dy1, float dx2, float dy2) 画二次贝塞尔曲线-->这条二次贝塞尔曲线的起点就是当前位置，而参数中的 x1, y1 和 x2, y2 则分别是控制点和终点的坐标。和 rLineTo(x, y) 同理，rQuadTo(dx1, dy1, dx2, dy2) 的参数也是相对坐标
                贝塞尔曲线：贝塞尔曲线是几何上的一种曲线。它通过起点、控制点和终点来描述一条曲线，主要用于计算机图形学。概念总是说着容易听着难，总之使用它可以绘制很多圆润又好看的图形，但要把它熟练掌握、灵活使用却是不容易的。不过还好的是，一般情况下，贝塞尔曲线并没有什么用处，只在少数场景下绘制一些特殊图形的时候才会用到，所以如果你还没掌握自定义绘制，可以先把贝塞尔曲线放一放，稍后再学也完全没问题。至于怎么学，贝塞尔曲线的知识网上一搜一大把，我这里就不讲了。
            cubicTo(float x1, float y1, float x2, float y2, float x3, float y3) / rCubicTo(float x1, float y1, float x2, float y2, float x3, float y3) 画三次贝塞尔曲线-->和上面这个 quadTo() rQuadTo() 的二次贝塞尔曲线同理，cubicTo() 和 rCubicTo() 是三次贝塞尔曲线，不再解释。
            moveTo(float x, float y) / rMoveTo(float x, float y) 移动到目标位置-->不论是直线还是贝塞尔曲线，都是以当前位置作为起点，而不能指定起点。但你可以通过 moveTo(x, y) 或  rMoveTo() 来改变当前位置，从而间接地设置这些方法的起点。
                paint.setStyle(Style.STROKE);
                path.lineTo(100, 100); // 画斜线
                path.moveTo(200, 100); // 我移~~
                path.lineTo(200, 0); // 画竖线
            *第二组还有两个特殊的方法： arcTo() 和 addArc()。它们也是用来画线的，但并不使用当前位置作为弧线的起点。
            arcTo(RectF oval, float startAngle, float sweepAngle, boolean forceMoveTo) / arcTo(float left, float top, float right, float bottom, float startAngle, float sweepAngle, boolean forceMoveTo) / arcTo(RectF oval, float startAngle, float sweepAngle) 画弧形-->这个方法和 Canvas.drawArc() 比起来，少了一个参数 useCenter，而多了一个参数 forceMoveTo 。 少了 useCenter ，是因为 arcTo() 只用来画弧形而不画扇形，所以不再需要 useCenter 参数；而多出来的这个 forceMoveTo 参数的意思是，绘制是要「抬一下笔移动过去」，还是「直接拖着笔过去」，区别在于是否留下移动的痕迹。
            addArc(float left, float top, float right, float bottom, float startAngle, float sweepAngle) / addArc(RectF oval, float startAngle, float sweepAngle)-->又是一个弧形的方法。一个叫 arcTo ，一个叫 addArc()，都是弧形，区别在哪里？其实很简单： addArc() 只是一个直接使用了 forceMoveTo = true 的简化版 arcTo() 。
            close() 封闭当前子图形-->和 lineTo(起点坐标) 是完全等价的。

    Path 方法第二类：辅助的设置或计算
        Path.setFillType(Path.FillType ft) 设置填充方式，方法中填入不同的 FillType 值，就会有不同的填充效果。FillType 的取值有四个：
            EVEN_ODD
            WINDING （默认值）
            INVERSE_EVEN_ODD
            INVERSE_WINDING

                EVEN_ODD 是「交叉填充」：即 even-odd rule （奇偶原则）：对于平面中的任意一点，向任意方向射出一条射线，这条射线和图形相交的次数（相交才算，相切不算哦）如果是奇数，则这个点被认为在图形内部，是要被涂色的区域；如果是偶数，则这个点被认为在图形外部，是不被涂色的区域。还以左右相交的双圆为例：
                WINDING 是「全填充」：WINDING即 non-zero winding rule （非零环绕数原则）：首先，它需要你图形中的所有线条都是有绘制方向的：
                    然后，同样是从平面中的点向任意方向射出一条射线，但计算规则不一样：以 0 为初始值，对于射线和图形的所有交点，遇到每个顺时针的交点（图形从射线的左边向右穿过）把结果加 1，遇到每个逆时针的交点（图形从射线的右边向左穿过）把结果减 1，最终把所有的交点都算上，得到的结果如果不是 0，则认为这个点在图形内部，是要被涂色的区域；如果是 0，则认为这个点在图形外部，是不被涂色的区域。

Paint方法:
    Paint.setColor(int color)用来设置绘制内容的颜色。你不止可以用它画红色的圆，也可以用它来画红色的矩形、红色的五角星、红色的文字
    Paint.setStyle(Paint.Style style)而如果你想画的不是实心圆，而是空心圆（或者叫环形），也可以使用  paint.setStyle(Paint.Style.STROKE) 来把绘制模式改为画线模式，FILL, STROKE 和  FILL_AND_STROKE 。FILL 是填充模式，STROKE 是画线模式（即勾边模式），FILL_AND_STROKE 是两种模式一并使用：既画线又填充。它的默认值是 FILL，填充模式。
    Paint.setStrokeWidth(float width)在 STROKE 和 FILL_AND_STROKE 下，还可以使用 paint.setStrokeWidth(float width) 来设置线条的宽度：
    Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);  在绘制的时候，往往需要开启抗锯齿来让图形和文字的边缘更加平滑。开启抗锯齿很简单，只要在  new Paint() 的时候加上一个 ANTI_ALIAS_FLAG 参数就行：
    Paint.setTextSize(float textSize)通过 Paint.setTextSize(textSize)，可以设置文字的大小。
